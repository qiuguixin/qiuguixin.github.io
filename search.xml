<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[rails 简单论坛实战]]></title>
      <url>%2F2017%2F07%2F22%2Frails101%2F</url>
      <content type="text"><![CDATA[1-1 前言目标这一份是写给 Rails 新手的中级训练教材。接下来会以一个“讨论版”为主题，实际让同学了解如何“从零打造”手写出一个网站。 这个讨论版会有： 使用者注册以及登录功能 开新讨论区、留言功能 加入讨论区、退出讨论区功能 权限管理功能 热门文章排序功能 了解什么是 RESTful 当你把这次应用程序实作完成，并上线后，你会学会： 怎么把需求变成会动的 Rails 应用程序 如何在 Rails 套版 如何制作使用者登录功能 重要 Rails 观念以及 API CRUD RESTful member, collection helper partial scope 找到 Rails 第三方 gem 的技巧 要怎么把你的应用程序放到网络上 这几乎是一个 Rails 新手应该学的一切了，有了这些基础技巧之后，你再学更难的技巧，或者是要自己做出复杂的东西，就不会那么容易失败了。 时程 约 30 小时 Rails 开发 建议每天使用 4 小时来完成作业（约需5-7天） 重复练习三遍（相信我，你会越练越快的…） 需求我们会用这些来做： ruby 2.1.2 、2.2.0 、2.3.1用 RVM 安装（Mac 或 Linux） rails 5.0.0 bundler Atom编辑器 这些应该都要在第一份教材就装好，确定它们都妥妥的。 如何确认一切没问题？运行终端机，输入： irb 2.3.1 :001 &gt; 1 + 2=&gt; 3 2.3.1 :002 &gt; require &quot;active_support&quot;=&gt; true 2.3.1 :003 &gt; exit 这些都可以成功执行的话，就是没问题了。 提示：在 irb 里运行命令的话，最后记得输入 exit 退出。 效能！效率！我非常推荐你这样做： 打开终端机并开两个标签页： 一个放着跑 rails s 一个用来做平常的终端机指令 重新打开你的浏览器（推荐chrome），或是把其他窗口关掉 打开新的窗口并开两个标签页 一个用来看本教学 一个用来测试你的程序 打开Atom编辑器，然后不要关掉它。我们不会中途离开。 把其他应用程序都隐藏起来，关掉facebook 、微信和其他即时通讯软件、别的干扰物。 把跟你互动的东西最少化，可以减少你分心在这些东西的次数与耗费的时间（比方说在浏览器里打开 50 个分页，这会干扰到你并且浪费你的时间） 格式每一课的格式都会长这样： 目标 叙述我们要做什么。 步骤 跟着做，但是这时候你还不知道原理。 解释 关于这些步骤实际上做了什么的细节，详述原因与效果。将一切都连在一起。 注意如果你刚刚完成第二课的初级练习 请在终端机运行 rails server 的窗口（或者标签页）中按 ctrl + c 终止运行，然后按 command + q 退出终端机。 请在 Atom 编辑器的界面按 command + w 关闭所有的标签页，然后点击任务栏左上角 Atom &gt; Quit 退出编辑器。 在开始第二遍，第三遍作业时，同样执行以上两个步骤。 2-1 本章目标这一章的最终目标，是让各位同学在本章结束后，可以得到一个套好 Bootstrap 样式的空项目。 最后成果会长成这样： 2-2 建立新项目rails new rails101 cd rails101 git init git add . git commit -m &quot;Initial Commit&quot; 2-3 帮 Rails 项目穿上衣服“Bootstrap”git checkout -b ch01 1gem &apos;bootstrap-sass&apos; bundle install mv app/assets/stylesheets/application.css app/assets/stylesheets/application.scss 12@import "bootstrap-sprockets";@import "bootstrap"; git add .git commit -m &quot;add bootstrap to project&quot; 2-4 套用 Bootstrap 的 html 样式 （以下内容无需记忆）目标 上一节只是“挂上”Bootstrap 使用的 CSS 这一节则是让全站的 HTML 架构，套用 Bootstrap 的制服 步骤Step 1. 新增 app/views/common 文件夹mkdir app/views/common Step 2. 新增 navbartouch app/views/common/_navbar.html.erb 填入 app/views/common/_navbar.html.erb 123456789101112131415&lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;Rails 101&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;collapse navbar-collapse&quot;&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt; &lt;%= link_to(&quot;登录&quot;, &apos;#&apos;) %&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; Step 3. 新增 footertouch app/views/common/_footer.html.erb 填入 app/views/common/footer.html.erb 123456&lt;footer class=&quot;container&quot; style=&quot;margin-top: 100px;&quot;&gt; &lt;p class=&quot;text-center&quot;&gt;Copyright ©2017 Rails101 &lt;br&gt;Design by &lt;a href=&quot;http://courses.growthschool.com/courses/rails-101/&quot; target=_new&gt;xdite&lt;/a&gt; &lt;/p&gt;&lt;/footer&gt; Step 4. 修改全域 HTML 样式 application.html.erbapp/views/layouts/application.html.erb 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Rails101&lt;/title&gt; &lt;%= csrf_meta_tags %&gt; &lt;%= stylesheet_link_tag &apos;application&apos;, media: &apos;all&apos;, &apos;data-turbolinks-track&apos;: &apos;reload&apos; %&gt; &lt;%= javascript_include_tag &apos;application&apos;, &apos;data-turbolinks-track&apos;: &apos;reload&apos; %&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;%= render &quot;common/navbar&quot; %&gt; &lt;%= yield %&gt; &lt;/div&gt; &lt;%= render &quot;common/footer&quot; %&gt; &lt;/body&gt;&lt;/html&gt; Step 5. 产生一个新的空 Hello World 页面 （放在 welcome#index) 新增一个 welcome controller rails g controller welcome 新增一个空的 HelloWorld 页面 touch app/views/welcome/index.html.erb 填入 app/views/welcome/index.html.erb 1&lt;h1&gt; Hello World! &lt;/h1&gt; Step 6. 将首页指到 welcome 下的 index.html.erb 页面修改 config/routes.rb，改成以下内容 config/routes.rb 123Rails.application.routes.draw do root &apos;welcome#index&apos;end Step 7. git 进度存档git add .git commit -m &quot;add bootstrap html&quot; Step 8. 运行 Rails Serverrails s 最后完成画面： 2-5 制作漂亮的“提示信息” （以下内容无需记忆）目标 你应该看过一些网站，有这样的提示信息吧？ 这一节的目的在于让你学习到，在 Rails 内如何配合 Bootstrap 内建的特效，建立“提示信息”。 步骤Step 1. 将 Bootstrap 的 js 提示套件 bootstrap/alert “挂”进项目里面在 require_tree 上加入 //= require bootstrap/alert app/assets/javascripts/application.js 123456... (一堆注解)//= require jquery//= require jquery_ujs//= require turbolinks+//= require bootstrap/alert//= require_tree . +号在这里是新增一行代码的意思，不用复制贴上这个+号本身，只要粘贴后面的代码就可以了 Step 2. 新增 app/views/common/_flashes.html.erbtouch app/views/common/_flashes.html.erb 填入 app/views/common/_flashes.html.erb 12345678&lt;% if flash.any? %&gt; &lt;% user_facing_flashes.each do |key, value| %&gt; &lt;div class=&quot;alert alert-dismissable alert-&lt;%= flash_class(key) %&gt;&quot;&gt; &lt;button class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;×&lt;/button&gt; &lt;%= value %&gt; &lt;/div&gt; &lt;% end %&gt;&lt;% end %&gt; Step 3. 加入 app/helpers/flashes_helper.rbtouch app/helpers/flashes_helper.rb 加入以下内容： app/helpers/flashes_helper.rb 1234567891011module FlashesHelper FLASH_CLASSES = &#123; alert: &quot;danger&quot;, notice: &quot;success&quot;, warning: &quot;warning&quot;&#125;.freeze def flash_class(key) FLASH_CLASSES.fetch key.to_sym, key end def user_facing_flashes flash.to_hash.slice &quot;alert&quot;, &quot;notice&quot;, &quot;warning&quot; endend Step 4. 在 application.html.erb 内加入 flash 这个 partial在 &lt;%= yield %&gt; 前加入 &lt;%= render “common/flashes” %&gt; app/views/layouts/application.html.erb 12&lt;%= render &quot;common/flashes&quot; %&gt; &lt;%= yield %&gt; Step 5. git 存档git add .git commit -m &quot;add bootstrap flash function&quot; Step 6: 测试 flash helper 的功能修改 app/controllers/welcome_controller.rb。加入 flash[:notice] = “早安！你好！”。你应该可以看到系统跳出“绿色”提示窗。 app/controllers/welcome_controller.rb 12345class WelcomeController &lt; ApplicationController def index flash[:notice] = &quot;早安！你好！&quot; endend 修改 app/controllers/welcome_controller.rb。加入 flash[:alert] = “晚安！该睡了！”。你应该可以看到系统跳出“红色”提示窗。 app/controllers/welcome_controller.rb 12345class WelcomeController &lt; ApplicationController def index flash[:alert] = &quot;晚安！该睡了！&quot; endend 修改 app/controllers/welcome_controller.rb。加入 flash[:warning] = “这是 warning 信息！”。你应该可以看到系统跳出“黄色”提示窗。 app/controllers/welcome_controller.rb 12345class WelcomeController &lt; ApplicationController def index flash[:warning] = &quot;这是 warning 信息！&quot; endend 2-6 参考：git 常用指令教学这边是一些常用的 git 指令，常用就会自然记起来，不用硬背，你可以在遇到问题的时候再回来看这篇。 存档：最一开始的时候要先执行存档：cd 你的项目文件夹名称git initgit add .git commit -m &quot;对于修改部分的简要叙述&quot; 新增一个分支：git checkout -b 你想取的分支名称 这样你的存档会自动被保留在这个分支里。如果不小心做烂了，可以直接切回上一个分支去做。 切换分支：git checkout 你想要切换到的分支名称举例来说，假设你从01开始做，做到02的时候烂掉了你可以 git checkout 01 回到01再重新开始做 那这个烂掉的02要怎么办呢？虽然你可以产生另一个新的02-1，但还是建议把错误的删除掉，这样才不会做到最后变得乱七八糟的。 删除掉branch的方法：先离开你要删除的分支，接着执行 git branch -D 你要删除的分支名称就可以了。 3-1 建立讨论群的架构目标在这一章，我们要带大家设计出一个讨论群“列表”。我们会完成以下事项： 讨论群要有“标题”与“叙述” 使用者要可以看到“讨论群一览表” 步骤Step 0. git checkout -b ch02因为我们现在要实作第二章的内容，新增一个 branch 把实作内容集中在 ch02 是比较合理的。将来回顾就可以比较清楚 在 ch02我们做了哪一些练习。 git checkout -b ch02 Step 1. 设计 Group 的 model 架构为了做到在讨论群要有“标题”与“叙述”，我们在这里要建立一个 model Group，并建立数据表 group 的两个栏位: title (string 字串属性) description (text 文字属性) rails g model group title:string description:text 将数据库建立起来，并执行 rake db:migrate rake db:migrate 提示：每次产生 migration 之后都要运行 rake db:migrate 。 Step 2. 产生 groups controller 接下来我们要建立一个可以展示“讨论群一览表”的功能 这个地方会是 groups_controller 下的 index action rails g controller groups Step 3. 建立 index action 以及 index 的 view修改 app/controllers/groups_controller.rb app/controllers/groups_controller.rb 12345class GroupsController &lt; ApplicationController def index @groups = Group.all endend touch app/views/groups/index.html.erb app/views/groups/index.html.erb 12345678910111213141516171819202122232425262728&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;group&quot;&gt; &lt;%= link_to(&quot;New group&quot;, new_group_path, class: &quot;btn btn-primary pull-right&quot;) %&gt; &lt;/div&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;#&lt;/td&gt; &lt;td&gt;Title&lt;/td&gt; &lt;td&gt;Description&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% @groups.each do |group| %&gt; &lt;tr&gt; &lt;td&gt;#&lt;/td&gt; &lt;td&gt;&lt;%= link_to(group.title, group_path(group)) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= group.description %&gt;&lt;/td&gt; &lt;td&gt; &lt;%= link_to(&quot;Edit&quot;, edit_group_path(group), class: &quot;btn btn-sm btn-default&quot;)%&gt; &lt;%= link_to(&quot;Delete&quot;, group_path(group), class: &quot;btn btn-sm btn-default&quot;, method: :delete, data: &#123; confirm: &quot;Are you sure?&quot; &#125; )%&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; Step 4. 在 routing 上挂上 groups在 root ‘welcome#index’ 前加上一行 resources :groups config/routes.rb [http://localhost:3000/groups](http://localhost:3000/groups) 可以看到以下成果1234Rails.application.routes.draw do resources :groups root &apos;welcome#index&apos;end 当然现在没有东西，空荡荡的。等一下让我们来加一些数据。 Step 5. 添加一些数据。首先，打开 rails console rails console 然后再输入 Group.create(title: &quot;Board 1&quot;, description: &quot;Board 1 body&quot;)Group.create(title: &quot;Board 2&quot;, description: &quot;Board 2 body&quot;) 再重新打开 http://localhost:3000/groups 可以看到以下成果 Step 6. git 存档输入 exit 命令 退出rails console git add .git commit -m &quot;create groups index&quot; 3-2 将首页换成讨论群一览表目标在这一节，我们会完成以下事项： 使用者在首页，可以直接看到“讨论群一览表” 步骤Step 1. 修改 routing把 root ‘welcome#index’ 删掉，换成 root ‘groups#index’ （记得 + - 不要打进去，他们各代表“加这一行” / “减这一行”的意思。） config/routes.rb 12345Rails.application.routes.draw do resources :groups+ root &apos;groups#index&apos;- root &apos;welcome#index&apos;end 然后你就可以在 http://localhost:3000/ 看到 Group 一览表了 Step 2. git 存档git add .git commit -m &quot;replace root with groups#index&quot; 4-1 本章目标目标 实作看板的“新增” new / create 实作看板的“编辑” edit / update 实作看板的“删除” destroy 额外会谈到的主题是： 使用 gem “simple_form” 产生表单 限制看板标题“不得为空” 4-2 实作讨论群“新增”功能目标 这一章我们要实作 讨论群 的新增功能 步骤Step 0. git checkout -b ch03因为我们现在要实作第三章的内容，新增一个 branch 把实作内容集中在 ch03 是比较合理的。将来回顾就可以比较清楚 在 ch03 我们做了哪一些练习。 git checkout -b ch03 Step 1. 建立 new action修改 app/controllers/groups_controller.rb 加入 new action app/controllers/groups_controller.rb 123456789class GroupsController &lt; ApplicationController def index @groups = Group.all end+ def new+ @group = Group.new+ endend Step 2. 建立 new action 的表单touch app/views/groups/new.html.erb app/views/groups/new.html.erb 123456789101112131415161718&lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;h2&gt;新增讨论版&lt;/h2&gt; &lt;hr&gt; &lt;%= form_for @group do |f| %&gt; 标题 &lt;%= f.text_field :title %&gt; &lt;br&gt; 叙述 &lt;br&gt; &lt;%= f.text_area :description %&gt; &lt;br&gt; &lt;%= f.submit &quot;Submit&quot;, :disable_with =&gt; &apos;Submiting...&apos; %&gt; &lt;% end %&gt;&lt;/div&gt; 然后打开 http://localhost:3000/groups/new，可以见到成果 Step 3. git 存档git add .git commit -m &quot;implement groups#new&quot; Step 4. 建立 create action，接收数据并储存目前还只是个表单画面，无法将数据送出后成功建立出一笔讨论版的数据，缺了 action create。如果此时你按下 Submit，会看到这样的画面： 所以这时候，我们要实作 create action，接收 new 里的表单送出的信息，变成一笔存在数据库里的数据。 修改 app/controllers/groups_controller.rb app/controllers/groups_controller.rb 1234567891011121314151617181920212223class GroupsController &lt; ApplicationController def index @groups = Group.all end def new @group = Group.new end+ def create+ @group = Group.new(group_params)+ @group.save++ redirect_to groups_path+ end++ private++ def group_params+ params.require(:group).permit(:title, :description)+ end end 完成后再送一次即可成功建立数据，可以多建几笔数据测试功能。 Step 5. git 存档git add .git commit -m &quot;implement groups#create&quot; 4-3 实作讨论群“浏览”功能目标 这一章我们要实作 讨论群 的浏览功能 这时候如果直接点 index 上的 title 连结, 会跳出下面的错误信息： 我们要修正这个问题，让使用者可以浏览这个页面 步骤Step1: 建立 show action在 app/controllers/groups_controller.rb 加入 show action app/controllers/groups_controller.rb 1234567891011121314151617181920212223242526class GroupsController &lt; ApplicationController def index @groups = Group.all end+ def show+ @group = Group.find(params[:id])+ end def new @group = Group.new end def create @group = Group.new(group_params) @group.save redirect_to groups_path end private def group_params params.require(:group).permit(:title, :description) endend Step 2: 加入 app/views/groups/show.html.erbtouch app/views/groups/show.html.erb 加入以下内容 app/views/groups/show.html.erb 1234567&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;group&quot;&gt; &lt;%= link_to(&quot;Edit&quot;, edit_group_path(@group), class: &quot;btn btn-primary pull-right&quot;)%&gt; &lt;/div&gt; &lt;h2&gt;&lt;%= @group.title %&gt;&lt;/h2&gt; &lt;p&gt;&lt;%= @group.description %&gt;&lt;/p&gt;&lt;/div&gt; 然后，当你浏览 http://localhost:3000/groups/1 时，页面就会长这样 Step 3 : git 存档git add .git commit -m &quot;implement groups#show&quot; 4-4 实作讨论群“编辑”功能目标 这一节我们要实作 讨论群 的编辑功能 步骤：Step 1. 建立 edit action修改 app/controllers/groups_controller.rb 加入 edit action app/controllers/groups_controller.rb 1234567891011121314151617class GroupsController &lt; ApplicationController # 略 ... def show @group = Group.find(params[:id]) end+ def edit+ @group = Group.find(params[:id])+ end # 略 ... end Step 2. 建立 edit action 的表单新增 app/views/groups/edit.html.erb touch app/views/groups/edit.html.erb app/views/groups/edit.html.erb 123456789101112131415161718&lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;h2&gt;编辑讨论版&lt;/h2&gt; &lt;hr&gt; &lt;%= form_for @group do |f| %&gt; 标题 &lt;%= f.text_field :title %&gt; &lt;br&gt; 叙述 &lt;br&gt; &lt;%= f.text_area :description %&gt; &lt;br&gt; &lt;%= f.submit &quot;Submit&quot;, :disable_with =&gt; &apos;Submiting...&apos; %&gt; &lt;% end %&gt;&lt;/div&gt; 然后打开 http://localhost:3000/groups/1/edit，可以见到成果 Step 3. git 存档git add .git commit -m &quot;implement groups#edit &quot; Step 4. 实作 update action这时候我们可以尝试修改里面的数据，并试着送出。但是我们发现会跳出错误信息，提醒我们 update 还没实作： 所以这时候，我们要实作 update action，接收 edit 里的表单送出的信息，真正更新存在数据库里的数据。 修改 app/controllers/groups_controller.rb app/controller/groups_controller.rb 12345678910111213141516171819202122class GroupsController &lt; ApplicationController # ... 略 def create @group = Group.new(group_params) @group.save redirect_to groups_path end+ def update+ @group = Group.find(params[:id])++ @group.update(group_params)++ redirect_to groups_path, notice: &quot;Update Success&quot;+ end # ... 略end 然后试着更新一下数据，成功画面应该会有“绿色”提示信息。 Step 5. git 存档git add .git commit -m &quot;implement groups#update &quot; 4-5 实作讨论群“删除”功能目标 这一节我们要实作 讨论群 的删除功能 当我们点击 delete 按钮的时候, 会跳出下面的错误信息 步骤：Step1. 建立 delete actionapp/controllers/groups_controller.rb 1234567891011121314151617 # .... 略 def update @group = Group.find(params[:id]) @group.update(group_params) redirect_to groups_path, notice: &quot;Update Success&quot; end+ def destroy+ @group = Group.find(params[:id])+ @group.destroy+ flash[:alert] = &quot;Group deleted&quot;+ redirect_to groups_path+ end # .... 略 然后，按下删除键之后，就可以把该笔记录删除。 如果成功的话，可以看到显示“红色”的信息。 Step 2. git 存档git add .git commit -m &quot;implement groups#destroy &quot; 4-6 限制“标题为空”的Group，不能被新增目标 有时候我们会遇到使用者手残，直接送出全空的表单，结果就出现空文章 因此我们要加上一个限制，让使用者不能送出“空标题”文章才对 步骤Step 1: 在 Group model 加入“标题限制”修改 app/models/group.rb 让它长得像这样 app/models/group.rb 123class Group &lt; ApplicationRecord validates :title, presence: trueend 这样一来，就算送出了空的表单，也不会产生任何纪录。 但我们真正希望达到的效果是像这样子的，送出了空表单，使用者能够确切地知道，自己是因为什么错误被拦下： Step 2: 在 groups_controller 里面加入储存失败的判断修改 app/controllers/groups_controller.rb 将 create action 修改成这样： app/controllers/groups_controller.rb 123456789def create @group = Group.new(group_params) if @group.save redirect_to groups_path else render :new end end 然后修改 app/views/groups/new.html.erb 在 form_for 下方加入这一段： app/views/groups/new.html.erb 1234567&lt;% if @group.errors.any? %&gt;&lt;ul&gt; &lt;% @group.errors.full_messages.each do |msg| %&gt; &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;% end %&gt; 然后就可以产生这样的效果 Step 3 : git 存档git add .git commit -m &quot;add validation to title&quot; Step 4 : 修改 edit action还有一种情况是，在修改时，把标题改成空白的。所以我们也要避免这样的情况发生。 修改 app/controllers/groups_controller.rb，的 update action 让他长得像这样 app/controllers/groups_controller.rb 12345678def update @group = Group.find(params[:id]) if @group.update(group_params) redirect_to groups_path, notice: &quot;Update Success&quot; else render :edit end end 然后修改 app/views/groups/edit.html.erb 也在 form_for 下方加入这一段： app/views/groups/edit.html.erb 1234567&lt;% if @group.errors.any? %&gt;&lt;ul&gt; &lt;% @group.errors.full_messages.each do |msg| %&gt; &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;% end %&gt; 这样，在“编辑”时，也有一样的效果。 Step 5 : git 存档git add .git commit -m &quot;add validation to title apply to edit/update&quot; 本节常见问题validates :title, presence: true 是什么意思 这是 Rails 的 Model 内建的“验证”函式。意思是“不得为空”。 其实 Rails 还有很多内建验质函式，你可以看这里：http://guides.rubyonrails.org/active_record_validations.html 4-7 共用“表单”目标 把 new 与 edit 重复的表单代码，抽成一个共用文件 我们观察到，new 与 edit 都有相同的“表单代码”，显得相当累赘。在这里我们可以利用一个 Rails 内建的架构 partial去整理设计。 步骤Step 1: 产生 app/views/groups/_form.html.erbtouch app/views/groups/_form.html.erb 填入以下内容： app/views/groups/_form.html.erb 123456789101112131415161718&lt;%= form_for @group do |f| %&gt;&lt;% if @group.errors.any? %&gt;&lt;ul&gt; &lt;% @group.errors.full_messages.each do |msg| %&gt; &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;% end %&gt;标题&lt;%= f.text_field :title %&gt;&lt;br&gt;叙述&lt;br&gt;&lt;%= f.text_area :description %&gt;&lt;br&gt;&lt;%= f.submit &quot;Submit&quot;, :disable_with =&gt; &apos;Submiting...&apos; %&gt;&lt;% end %&gt; Step 2: 修改 app/views/groups/new.html.erb修改 app/views/groups/new.html.erb，把原先重复的表单代码“整段删掉”，改成 &lt;%= render “form” %&gt; app/views/groups/new.html.erb 12345678&lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;h2&gt;新增讨论版&lt;/h2&gt; &lt;hr&gt; &lt;%= render &quot;form&quot; %&gt;&lt;/div&gt; Step 3: 修改 app/views/groups/edit.html.erb修改 app/views/groups/edit.html.erb，把原先重复的表单源代码“整段删掉”，改成 &lt;%= render “form” %&gt; app/views/groups/edit.html.erb 123456&lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;h2&gt;编辑讨论版&lt;/h2&gt; &lt;hr&gt; &lt;%= render &quot;form&quot; %&gt;&lt;/div&gt; Step 4: git 存档git add .git commit -m &quot;move form to partial&quot; 本节常见问题教材里的render “form”是什么意思？其实这是 &lt;%= render :partial =&gt; “form” %&gt; 的“缩写”，意思是我要引用 Partial (局部）页面的方式。因为我们发现有很大量的程式码重复，所以可以用这样的方式收纳。它的规则是同目录底下的 _xxxx.html.erb 4-8 将表单换为 Bootstrap 提供的版型目标 将表单换为 Bootstrap 提供的版型 虽然我们已经有看起来还可以的表单，但是 Bootstrap 本身提供的表单版型更棒。 这一章，我们要示范怎么换成 Bootstrap 的表单版型。 步骤Step 1: 修改 app/views/groups/_form.html.erb修改 app/views/groups/_form.html.erb，换成以下内容 app/views/groups/_form.html.erb 12345678910111213141516&lt;%= form_for @group do |f| %&gt;&lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;form-group string optional&quot;&gt; &lt;%= f.label &quot;title&quot;, :class =&gt; &quot;string optional control-label&quot; %&gt; &lt;%= f.text_field :title, :class =&gt; &quot;string optional form-control&quot; %&gt; &lt;/div&gt; &lt;div class=&quot;form-group string optional&quot;&gt; &lt;%= f.label &quot;description&quot;, :class =&gt; &quot;string optional control-label&quot; %&gt; &lt;%= f.text_area :description, :class =&gt; &quot;string optional form-control&quot; %&gt; &lt;/div&gt;&lt;/div&gt;&lt;%= f.submit &quot;Submit&quot;, class: &quot;btn btn-primary&quot;, data: &#123; disable_with: &quot;Submiting...&quot; &#125; %&gt;&lt;% end %&gt; 然后打开 http://localhost:3000/groups/new 就可以看到这样的成果了 Step 2： git 存档git add .git commit -m &quot;style form with bootstrap&quot; Step 3: 使用 SimpleForm 简化在这张新的表单 HTML 中，我们见到很啰唆的语句： 1234&lt;div class=&quot;form-group string optional&quot;&gt; &lt;%= f.label &quot;title&quot;, :class =&gt; &quot;string optional control-label&quot; %&gt; &lt;%= f.text_field :title, :class =&gt; &quot;string optional form-control&quot; %&gt;&lt;/div&gt; 然后每一个栏位，都必须要用 bootstrap 指定的样式，重新装潢。但是如此一来，要是在栏位很多时，要写的 HTML 就要写上不少。有没有方法可以简化呢？ 这边我们要介绍一个 gem 叫做 simple_form，它可以帮你简化复杂的表单这件事。 首先我们要来安装 simple_form 打开 Gemfile，然后新增一行 gem ‘simple_form’ Gemfile 12gem &apos;bootstrap-sass&apos;+ gem &apos;simple_form&apos; 然后执行 bundle install 安装 gem。 Step 4: 安装 simple_form for bootstrap 的设定执行： rails generate simple_form:install --bootstrap 然后重开 rails server（ 按 ctrl＋c 终止 rails server， 再运行 rails s） 这个指令会产生两个文件 config/initializers/simple_form.rb config/initializers/simple_form_bootstrap.rb （这个是 Bootstrap 表单的“布景”) Step 5: 修改 app/views/groups/_form.html.erb把内容改成 app/views/groups/_form.html.erb 1234567&lt;%= simple_form_for @group do |f| %&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%= f.input :title, input_html: &#123; class: &quot;form-control&quot;&#125; %&gt; &lt;%= f.input :description, input_html: &#123; class: &quot;form-control&quot;&#125; %&gt; &lt;/div&gt; &lt;%= f.submit &quot;Submit&quot;, class: &quot;btn btn-primary&quot;, data: &#123; disable_with: &quot;Submiting...&quot; &#125; %&gt;&lt;% end %&gt; 然后打开 http://localhost:3000/groups/new 就可以看到这样的成果了。更棒的是 simple_form 提供的错误信息，直接是在栏位旁边的。更明显更直观。 Step 6: git 存档git add .git commit -m &quot;replace form with simple_form bootstrap template&quot; 本节常见问题为什么装完 gem 后要重开？* 因为 gem 不是动态载入 Rails 环境的，只有“你在 app/ 下开发的程式码”是动态载入，所以当有 app 外的档案被修改，你都应该“重开”治百病。 4-9（解说）Rails 的 CRUD 与 RESTful如果你还在做第一遍练习时，请跳过这整章解说，否则你大脑会乱掉！如果你还在做第一遍练习时，请跳过这整章解说，否则你大脑会乱掉！如果你还在做第一遍练习时，请跳过这整章解说，否则你大脑会乱掉！ 叫你滚出去还不明白吗？ 叫你滚出去还不明白吗？ 叫你滚出去还不明白吗？ 好。我现在确定你应该已经是做第二遍了，才看这一篇解说的。 HTTP 请求( Request）与 HTTP 动作 ( Verb）一般网页的运作原理是这样的： 使用者在浏览器输入了某个网址，点击了某个连结。这都叫发出 HTTP 请求 ( Request）。 而浏览器回应之后：产生页面，或者是重新导向。这都叫 HTTP 回应（ Response）。 一般来说，使用者最常使用的是两种类型 / 动作 ( Verb )的请求： GET 与 POST。 GET ：输入网址，点击某些网址。这都是 GET。 POST：送出表单。这叫做 POST RESTful 的基础概念因为 CRUD 是常见的操作行为，但是大家实作的方式、与网址设计方式不一样。造成很多维护上的困扰。 后来就有人发明 RESTful 这个概念，希望用 HTTP 的动作 ( Verb）一起去封装 CRUD 的行为。所以又多加了两个动作： PUT : 更新 ( update ) DELETE : 删除 ( delete） 而 Rails 的 Routing 也是依循这样的理念去设计。 Rails 的基础 RESTful概念由于RESTful是个新手不容易一下子理解的概念，号称学 Ruby on Rails 初期最大障碍。 在本篇尽量用浅显易懂的方式解释。如果看不懂也没关系，用背的！！ 一定要背起来！ 以下例子以 第三章， 做出 CRUD 功能的讨论版来解释： 讨论版有个群组叫： groups。在 Restful 的概念里把这个 groups 叫做 resources，“一组资源”的意思。 为了要控制它的运作，我们会创建一个新的 Controller文件 叫做 groups_controller.rb HTTP Verb 有四种： 新增 (create，使用 POST ) 读取 (read，使用 GET ) 更新 (update，使用 PUT ) 删除 (destroy，使用 DELETE) 在这组 controller 当中，我们会实作 7 个 Action ，4 张页面。 首页( index )：用来列出所有的讨论版，可以选择各个单版 （使用 GET ) 各个讨论版专属页面(show)：显示讨论版版名跟简介 (使用 GET ) 新增页面(new)：里面会有表单，填完以后可以送出 (使用 GET ) 产生数据（create) ：new 送出来的表单到 create 这个 action，新增一笔数据 ( 使用 POST ) 编辑页面(edit)：里面会有表单呈现现有数据来，填完数据后可以送出 (使用 GET ) 更新数据（update)：edit 送出来的表单可以到 update 这个 action，更新该笔数据 (使用 PUT ) 删除数据：送出删除请求，删除该笔数据（使用 DELETE） 这七个 action ，是每个CRUD功能里最基本的动作。只要我们在 controller.rb 里定义 (def) 好这七个方法当作动作 (action)。其他的部分 Rails 就会帮我们处理了。 像是设定 Routing (路由) 只需要简单一行: config/routes.rbresources :groups 这样不管浏览器端跑来什么样的请求 (request) ，Routing都会聪明地帮我们导向正确的 action 去运作后续流程。 网址对应关系对于网址跟对应的Action与页面来说 /groups/ 一定就是 index，首页，对应Routes路径： groups_path /groups/123 一定就是 show，名字为123的讨论版个版页面，对应Routes路径： group_path(123) /groups/123/edit 一定就是 edit，编辑讨论版123的表单页面，对应Routes路径：edit_group_path(123) /groups/new 一定就是 new，新增讨论版的表单页面，对应Routes路径(或称为helper)：new_group_path 总结所以制作一个 RESTful 风格的讨论版，我们仅需在Routes设定一行代码即可 5-1 本章目标本章目标: 安装“会员系统”（使用 devise） 在 navbar 安装登录/退出按钮 只有登录了的使用者，才可以建立群组 只有群组的建立者，才可以 编辑 / 删除群组 5-2 安装 devise gem目标 做会员系统似乎很困难？让我告诉你，在 Rails 内一点都不会！ 利用 devise 实作会员系统 步骤Step 0. git checkout -b ch04因为我们现在要实作第四章的内容，新增一个 branch 把实作内容集中在 ch04 是比较合理的。将来回顾就可以比较清楚 在 ch04 我们做了哪一些练习。 git checkout -b ch04 Step 1: 安装登录系统Devise 是一个 Rails 内热门的 gem，专门用来快速实作“登录系统”。在这一章我们会用 devise 实作登录功能。 Gemfile 新增一行 gem ‘devise’ Gemfilegem &#39;devise&#39; 然后执行 bundle install Step 2 : 产生会员系统的必要文件执行 rails g devise:installrails g devise userrake db:migrate 然后重开 rails server Step 3: 在 groups_controller 限制 “新增讨论群”必须先登录在 app/controllers/groups_controller.rb 加入一行 before_action :authenticate_user! , only: [:new] app/controllers/groups_controller.rb 12class GroupsController &lt; ApplicationController before_action :authenticate_user! , only: [:new] 然后这时候当你要访问 http://localhost:3000/groups/new 时，就会出现“登录画面”阻挡。可以注册一个账户试试效果。 Step 4: git 存档git add .git commit -m &quot;install devise&quot; 本节常见问题devise 帮我们做了什么？ 在这一阶段的细节，你不太需要知道他是怎么运作？（事实上也很复杂）* 你只要知道 before_action :authenticate_user! 可以帮你做出“限制使用者必须登入”的功能。 before_action 又是什么呢？before_action 后面加的往往是一个 controller 内的 method，在这里 :authenticate_user! 是 devise 提供的内建功能。 before_action :authenticate_user! , only: [:new]，表示“只有 new 需要登入” before_action :authenticate_user! 后面不加任何东西，表示这个 controller 下的所有 action 都要登入。* 你可以把 before_action 想像成“先过我这一关”的“拦截器” 5-3 让这个网站有实际“登录”、“退出”的功能目标 让右上角的“登录”可以实际有：“登录” / “退出的效果” 步骤Step 1: 修改 app/views/common/_navbar.html.erbapp/views/common/_navbar.html.erb 1234567891011121314151617- &lt;li&gt; - &lt;%= link_to(&quot;登录&quot;, &apos;#&apos;) %&gt; - &lt;/li&gt;+ &lt;% if !current_user %&gt;+ &lt;li&gt;&lt;%= link_to(&quot;注册&quot;, new_user_registration_path) %&gt; &lt;/li&gt;+ &lt;li&gt;&lt;%= link_to(&quot;登录&quot;, new_user_session_path) %&gt;&lt;/li&gt;+ &lt;% else %&gt;+ &lt;li class=&quot;dropdown&quot;&gt;+ &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot;&gt;+ Hi!, &lt;%= current_user.email %&gt;+ &lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;+ &lt;/a&gt;+ &lt;ul class=&quot;dropdown-menu&quot;&gt;+ &lt;li&gt; &lt;%= link_to(&quot;退出&quot;, destroy_user_session_path, method: :delete) %&gt; &lt;/li&gt;+ &lt;/ul&gt;+ &lt;/li&gt;+ &lt;% end %&gt; （+号代表新增的意思，复制贴上的时候请删掉它，-号代表删除的意思） Step 2: 修改 app/assets/javascripts/application.js加入 //= require bootstrap/dropdown app/assets/javascripts/application.js 12//= require bootstrap/alert+ //= require bootstrap/dropdown （+号代表新增的意思，复制贴上的时候请删掉它） 成果应该会是这样的效果。 Step 3: git 储存git add .git commit -m &quot;user can login/logout/signup&quot; **本节常见问题current_user 是什么？current_user 是 Devise 提供的“正在登入的当前用户”，你可以在 controller 或 view 里面使用它。 !current_user 又是什么! 表示不等于。!current_user 表示“现在没有登入的用户”（不在登入的状态） 5-4 让“群组”与“使用者”产生关联目标 我们要让“群组”记录是“被谁开的”。 并且在看板一览表显示出来“开设者的名称” 步骤Step 1: 新增 user_id 到 group 的 table 里执行 rails g migration add_user_id_to_group 然后打开刚刚新增的 migration 档，修改让它长得像这样 db/migrate/一串数字_add_user_id_to_group 12345class AddUserIdToGroup &lt; ActiveRecord::Migration[5.0] def change add_column :groups, :user_id, :integer endend 然后，执行 rake db:migrate Step 2: 连结 user 与 group 的双向关系修改 app/models/user.rb 加入 has_many :groups app/models/user.rb 12345678910class User &lt; ApplicationRecord # Include default devise modules. Others available are: # :confirmable, :lockable, :timeoutable and :omniauthable devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable, :validatable has_many :groupsend 修改 app/models/group.rb 加入 belongs_to :user app/models/group.rb 1234class Group &lt; ApplicationRecord belongs_to :user validates :title, presence: trueend Step 3: 在新增看板时，记录谁是群组的建立者 修改 app/controllers/groups_controller.rb，在需要“登入验证”的 action 列表再加入 create。 app/controllers/groups_controller.rb 12class GroupsController &lt; ApplicationController before_action :authenticate_user! , only: [:new, :create] 修改 app/controllers/groups_controller.rb，在 create 中，多加入一行 @group.user = current_user。 变成以下内容： app/controllers/groups_controller.rb 12345678910def create @group = Group.new(group_params) @group.user = current_user if @group.save redirect_to groups_path else render :new end end Step 4 : git 储存git add .git commit -m &quot;add user_id to group&quot; Step 5 : 修改 group 列表，将 user 的名字列上去修改 app/views/groups/index.html.erb 然后把 Creator 的信息加进去。（代码如下） app/views/groups/index.html.erb 123456789101112131415161718192021222324252627282930&lt;div class=&quot;col-md-12&quot;&gt; &lt;div class=&quot;group&quot;&gt; &lt;%= link_to(&quot;New group&quot;, new_group_path, class: &quot;btn btn-primary pull-right&quot;) %&gt; &lt;/div&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;#&lt;/td&gt; &lt;td&gt;Title&lt;/td&gt; &lt;td&gt;Description&lt;/td&gt;+ &lt;td&gt;Creator &lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% @groups.each do |group| %&gt; &lt;tr&gt; &lt;td&gt;#&lt;/td&gt; &lt;td&gt;&lt;%= link_to(group.title, group_path(group)) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= group.description %&gt;&lt;/td&gt;+ &lt;td&gt; &lt;%= group.user.email %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= link_to(&quot;Edit&quot;, edit_group_path(group), class: &quot;btn btn-sm btn-default&quot;)%&gt; &lt;%= link_to(&quot;Delete&quot;, group_path(group), class: &quot;btn btn-sm btn-default&quot;, method: :delete, data: &#123; confirm: &quot;Are you sure?&quot; &#125; )%&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 做完之后，打开 http://localhost:3000/ 会发现，首页怎么爆炸了。 别担心，这是因为我们之前创造的“群组”都是“无主”的。只要把这些“无主”的群组，通通删掉就行了。既然我们也进不去首页删群组了，我们就从 console 删吧。 Step 6: 删除所有“无主”的群组执行 rails console 然后输入 Group.delete_all 1exit 然后再打开 http://localhost:3000/ 就正常了。 这时候我们再新增一笔数据，就会显示 creator 的信息了。 Step 7 : git 存档git add .git commit -m &quot;show group&#39;s creator info &quot; **本节常见问题has_many 与 belongs_to 是什么意思？has_many 拥有很多belongs_to 属于就是这么直观！记得你一定要帮他们加上关联！ 5-5 只有群组的“创始者”可以“编辑”“删除”群组资讯目标 路人不应该可以看到“编辑”“删除”按钮 只有群组的“创始者”可以实际执行“编辑”“删除”群组资讯 步骤Step 1: 路人不应该可以看到“编辑”“删除”按钮让我们登出系统，在这里我们察觉一个严重的问题：明明是路人，怎么能看到“编辑”“删除”按钮的资讯呢？ 所以在这里我们要把“编辑”“删除”这两个按钮藏起来，限定 只有登入模式下 而且还必须是群组“创始者” 才能看得到这个两个按钮，否则路人是看不到的。 修改 app/views/groups/index.html.erb 加入 &lt;% if current_user &amp;&amp; current_user == group.user %&gt; 的判断式 app/views/groups/index.html.erb 1234567&lt;td&gt;+ &lt;% if current_user &amp;&amp; current_user == group.user %&gt; &lt;%= link_to(&quot;Edit&quot;, edit_group_path(group), class: &quot;btn btn-sm btn-default&quot;)%&gt; &lt;%= link_to(&quot;Delete&quot;, group_path(group), class: &quot;btn btn-sm btn-default&quot;, method: :delete, data: &#123; confirm: &quot;Are you sure?&quot; &#125; )%&gt;+ &lt;% end %&gt; &lt;/td&gt; 重新刷新首页，路人现在就看不到按钮了。 Step 2: git 存档git add .git commit -m &quot;people can&#39;t see edit button unless he is group owner&quot; Step 3: 路人不应该也可以“直接输入网址”去存取 edit / update / destroy action除了将按钮对路人隐藏外，我们还要考虑到一个情形，假设这个路人是知道 Rails 规则的，那么他可能输入 1http://localhost:3000/groups/某笔数据的ID/edit 网址，就直接可以编辑数据。 我们也要在 controller 做权限判断，滤掉这种人。 首先，我们先限定 edit / update / destroy 这三个操作动作，必须要是“登入”的使用者才能存取。 修改 app/controllers/groups_controller.rb 在 before_action :authenticate_user! 列表中，加入 :edit, :update, :destroy app/controllers/groups_controller.rb 12class GroupsController &lt; ApplicationController before_action :authenticate_user! , only: [:new, :create, :edit, :update, :destroy] 这样“没登录”的路人，就进不来了。但这只是第一步。 Step 4: 必须要是 group 拥有人，才能进入 edit，否则会被重导至首页，并显示错误信息。修改 app/controllers/groups_controller.rb 加入权限，如果不是“创始者”去存取，会显示没有权限的错误信息。 app/controllers/groups_controller.rb 1234567def edit @group = Group.find(params[:id]) if current_user != @group.user redirect_to root_path, alert: &quot;You have no permission.&quot; end end 这样当其他人，试图输入 1http://localhost:3000/groups/某笔数据的ID/edit 这样的网址，想要编辑数据，就会被挡住。 Step 5: 依样画葫芦的把“权限检查”的代码，套用到 update / destroy 上修改 app/controllers/groups_controller.rb 中的 update 与 destroy 部分。 app/controllers/groups_controller.rb 123456789101112131415161718192021222324def update @group = Group.find(params[:id]) if current_user != @group.user redirect_to root_path, alert: &quot;You have no permission.&quot; end if @group.update(group_params) redirect_to groups_path, notice: &quot;Update Success&quot; else render :edit end end def destroy @group = Group.find(params[:id]) if current_user != @group.user redirect_to root_path, alert: &quot;You have no permission.&quot; end @group.destroy redirect_to groups_path, alert: &quot;Group deleted&quot; end Step 6: git 存档git add .git commit -m &quot;check owner permission when access edit/update/destroy&quot; Step 7: 制作 find_group_and_check_permission我们发现 edit、update、destroy 这三个 action 都有一样的代码，看起来有点冗。 12345@group = Group.find(params[:id])if current_user != @group.user redirect_to root_path, alert: &quot;You have no permission.&quot;end 其实我们可以透过把它包装成一个函式的方式 find_group_and_check_permission 去省略这段冗余代码。 打开 app/controllers/groups_controller.rb 在 private 下，新增一个 find_group_and_check_permission app/controllers/groups_controller.rb 123456789101112131415private def find_group_and_check_permission @group = Group.find(params[:id]) if current_user != @group.user redirect_to root_path, alert: &quot;You have no permission.&quot; end end def group_params params.require(:group).permit(:title, :description) endend 再修正 edit app/controllers/groups_controller.rb 123def edit find_group_and_check_permission end 修正 update app/controllers/groups_controller.rb 12345678910def update find_group_and_check_permission if @group.update(group_params) redirect_to groups_path, notice: &quot;Update Success&quot; else render :edit end end 修正 destroy app/controllers/groups_controller.rb 123456def destroy find_group_and_check_permission @group.destroy redirect_to groups_path, alert: &quot;Group deleted&quot; end Step 8: 把 find_group_and_check_permission 挂到 before_action开发到这里你会发现一件事，find_group_and_check_permission 其实都是在这三个 action 的最前面开头执行的，所以你甚至可以这样写，把 find_group_and_check_permission 挂到 before_action app/controllers/groups_controller.rb 1234class GroupsController &lt; ApplicationController before_action :authenticate_user! , only: [:new, :create, :edit, :update, :destroy] before_action :find_group_and_check_permission, only: [:edit, :update, :destroy] 然后再把 edit update destroy 里的 find_group_and_check_permission 砍掉。变成这样： app/controllers/groups_controller.rb 123456789101112131415def edit end def update if @group.update(group_params) redirect_to groups_path, notice: &quot;Update Success&quot; else render :edit end end def destroy @group.destroy redirect_to groups_path, alert: &quot;Group deleted&quot; end Step 9: git 存档git add .git commit -m &quot;use before_action to find_group_and_check_permission&quot; Step 10 : 修掉 show 里面的 Edit 按钮做到这里，我们还发现一个地方，我们漏了改，那就是 show.html.erb 上面，还有一个 Edit 按钮我们还没有拔掉。 修改 app/views/groups/show.html.erb ，然后加入 加入 &lt;% if current_user &amp;&amp; current_user == @group.user %&gt; 的判断式 app/views/groups/show.html.erb 12345&lt;div class=&quot;group&quot;&gt; &lt;% if current_user &amp;&amp; current_user == @group.user %&gt; &lt;%= link_to(&quot;Edit&quot;, edit_group_path(@group), class: &quot;btn btn-primary pull-right&quot;)%&gt; &lt;% end %&gt; &lt;/div&gt; 如此按钮就被修掉了。 Step 11: git 存档git add .git commit -m &quot;add permission check on show page&quot; **本节常见问题= 与 == 与 != 他们三者是什么？ = 是指派。@groups = Group.all，把 Group.all 数值 指派给 @groups 的意思。 == “等于” != “不等于” 6-1 本章目标本章目标： 可以在群组里面新增 / 编辑 / 删除文章 文章必须要有“内容”，否则不允许被发表 6-2 建立文章的架构目标在这一章，我们要带大家在群里面可以发文章。我们会完成以下事项： 文章 Post 要有“内容”、“所属讨论群组”、“叙述” 发文网址是在 http://localhost:3000/groups/1/posts/new 步骤Step 0. git checkout -b ch05因为我们现在要实作第五章的内容，新增一个 branch 把实作内容集中在 ch05 是比较合理的。将来回顾就可以比较清楚 在 ch05 我们做了哪一些练习。 git checkout -b ch05 Step 1. 设计 Post 的 model 架构 文章内容要有“内容”、“所属讨论群组”、“叙述” 我们在这里要建立一个 model Post，并建立数据表 post 的三个栏位: content ( text 文字属性) 、group_id (integer 数字属性)、 user_id ( integer 数字属性） rails g model post content:text group_id:integer user_id:integer 将数据库建立起来，并执行 rake db:migrate rake db:migrate Step 2. 建立 Group / Post / User 三者间的关系 Group has_many posts app/models/group.rb 12345class Group &lt; ApplicationRecord belongs_to :user has_many :posts validates :title, presence: trueend User has_many posts app/models/user.rb 1234567891011class User &lt; ApplicationRecord # Include default devise modules. Others available are: # :confirmable, :lockable, :timeoutable and :omniauthable devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable, :validatable has_many :groups has_many :postsend Post belongs_to User Post belongs_to Group app/models/post.rb 1234class Post &lt; ApplicationRecord belongs_to :user belongs_to :groupend Step 3. git 存档git add .git commit -m &quot;add post and hook group/user relation&quot; Step 4. 建立 Post Controllerrails g controller posts Step 5. 设立 routing修改 config/routes.rb 将 resources :posts 加入 resources :groups 内。 config/routes.rb 1234567Rails.application.routes.draw do devise_for :users resources :groups do resources :posts end root &apos;groups#index&apos;end 做了这件事后，执行 rake routes 然后你就会发现， routing 列表内产生了 /groups/:group_id/posts/new 这样的网址支援。 Step 6. git 存档git add .git commit -m &quot;add posts nested route&quot; Step 7. 在 groups#show 新增 “发表文章”按钮修改 app/views/groups/show.html.erb 然后加入一行 app/views/groups/show.html.erb &lt;%= link_to(&quot;Write a Post&quot;, new_group_post_path(@group), class: &quot;btn btn-default pull-right&quot;)%&gt; 在权限判断的位置上面： 我们就得到了一颗可以新增文章的按钮 Step 8. git 存档git add .git commit -m &quot;add post button&quot; 6-3 实际发表文章目标： 实际把文章发在群里面 使用者可以在群里面看到文章一览表 步骤：Step 1: 实作 new / create action新增 new 与 create action 在 posts_controller app/controllers/posts_controller.rb 123456789101112131415161718192021222324252627282930class PostsController &lt; ApplicationController before_action :authenticate_user!, :only =&gt; [:new, :create] def new @group = Group.find(params[:group_id]) @post = Post.new end def create @group = Group.find(params[:group_id]) @post = Post.new(post_params) @post.group = @group @post.user = current_user if @post.save redirect_to group_path(@group) else render :new end end private def post_params params.require(:post).permit(:content) endend Step 2. 新增 app/views/posts/new.html.erbtouch app/views/posts/new.html.erb app/views/posts/new.html.erb 123456789101112&lt;h2 class=&quot;text-center&quot;&gt;新增文章&lt;/h2&gt;&lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt; &lt;%= simple_form_for [@group,@post] do |f| %&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;%= f.input :content, input_html: &#123; class: &quot;form-control&quot;&#125; %&gt; &lt;/div&gt; &lt;div class=&quot;form-actions&quot;&gt; &lt;%= f.submit &quot;Submit&quot;, disable_with: &quot;Submiting...&quot;, class: &quot;btn btn-primary&quot;%&gt; &lt;/div&gt; &lt;% end %&gt;&lt;/div&gt; Step 3. 修改 groups_controller 中的 show action 修改 app/controllers/groups_controller.rb app/controllers/groups_controller.rb 1234def show @group = Group.find(params[:id]) @posts = @group.posts end Step 4. 修改 groups/show.html.erb我们要修改 app/views/groups/show.html.erb，让文章能够显示出来，在&lt;%= @group.description %&gt;下，我们多加了一个表格做这件事。 app/views/groups/show.html.erb 123456789101112131415161718192021...（略） &lt;p&gt;&lt;%= @group.description %&gt;&lt;/p&gt;+ &lt;table class=&quot;table&quot;&gt;+ &lt;thead&gt;+ &lt;tr&gt;+ &lt;th&gt;文章内容&lt;/th&gt;+ &lt;th&gt;发表者&lt;/th&gt;+ &lt;th&gt;发表时间&lt;/th&gt;+ &lt;/tr&gt;+ &lt;/thead&gt;+ &lt;tbody&gt;+ &lt;% @posts.each do |post| %&gt;+ &lt;tr&gt;+ &lt;td&gt;&lt;%= post.content %&gt;&lt;/td&gt;+ &lt;td&gt;&lt;%= post.user.email %&gt;&lt;/td&gt;+ &lt;td&gt;&lt;%= post.created_at %&gt;&lt;/td&gt;+ &lt;/tr&gt;+ &lt;% end %&gt;+ &lt;/tbody&gt;+ &lt;/table&gt; 新增几笔文章试看看！ Step 5: 对 Post 加上 validation这时候我们发现，刚刚有文章不小心没填内容，就发出去变成空的。 为了防止这样的情形，我们还是要限制 post 的 content 要是为空，就不得送出。 修改 app/models/post.rb 加入 validates :content, presence: true app/models/post.rb 1234567class Post &lt; ApplicationRecord belongs_to :user belongs_to :group validates :content, presence: true end 之后要是再有使用者，送出空的内容，就会被挡下来。 Step 6. git 存档git add .git commit -m &quot;implement post create function&quot; 6-4 文章应该按照发表时间倒序排列目标 在文章列表上，应该让文章按照发表时间“倒序”排列，我们应该让最近发表的文章在“最上面”。 步骤Step 1. 修改 groups_controller修改 app/controllers/groups_controller.rb 的 show，让它最后长成以下样子： app/controllers/groups_controller.rb 1234def show @group = Group.find(params[:id]) @posts = @group.posts.order(&quot;created_at DESC&quot;) end 重新刷新，看板列表就会变成，按照发表时间“倒序”排列 Step 2. git 储存git add .git commit -m &quot;add order by created_at to group&#39;s post&quot; Step 3. 使用 scope 替代直接 orderapp/controllers/groups_controller.rb 1234def show @group = Group.find(params[:id]) @posts = @group.posts.order(&quot;created_at DESC&quot;) end 这里的 order(“created_at DESC”) 是“程序语句”，但不是“功能叙述”。我们作为旁观者，只能猜测这是要按照“最近的时序排列”。 如果能改成 @group.posts.recent 可能在维护性上更直观。 这里我们还可以用 Rails 里面的一个内建 API scope 让代码更直观一些。 scope 可以用来包装一些查询式，如果我们这里想要让最后的代码变成 @group.posts.recent 的话，作法如下： 修改 app/models/post.rb，加入一行 scope :recent, -&gt; { order(“created_at DESC”)} app/models/post.rb 1234567class Post &lt; ApplicationRecord # ... 略 scope :recent, -&gt; &#123; order(&quot;created_at DESC&quot;)&#125;end 然后修改 app/controllers/groups_controller.rb 中的 show，变成 app/controllers/groups_controller.rb 1234def show @group = Group.find(params[:id]) @posts = @group.posts.recent end 这样就可以了。 Step 4. git 储存git add .git commit -m &quot;using scope to write order by created_at to group&#39;s post&quot; 解说order(“created_at DESC”) 是什么？实际上呢，Model 里面的所有语句，看起来是“Ruby 语句”，实际上是 Rails 帮我们“翻译”成为了数据库语句。（这一套叫 ActiveRecord 框架） 如果有兴趣的话，Rails 的 Log 都有显示的。 比如说： Post.all 真正的数据库语句是 SELECT “posts”. FROM “posts”@group.posts.order(“created_at DESC”) 是 SELECT “posts”. FROM “posts” WHERE “posts”.”group_id” = ? ORDER BY created_at DESC 因为数据库语句也是个“巨坑”，Rails 开发的目的，在于希望程序员专注于“产品”的逻辑设计，而花上少一点时间去纠缠非常底层的细节。 在刚开始学习过程中，其实你是不太需要去纠结数据库语句的，大部份你想要捞的数据，ActiveRecord 都能帮你搞定，而且可以“形容”的非常“口语”。 scope 又是什么呢？你可以想像成，拿来包装“常用 query”的方法。理解到这里就可以了。 更多 scope 的用法：http://guides.rubyonrails.org/active_record_querying.html 6-5 加入文章分页功能目标 为文章列表加入分页功能。 一页 5 篇文章。 步骤Step 1: 安装 will_paginateRails 社群内有很多“分页”功能的 gem 可以办到这件事，其中最热门的 gem 叫 will_paginate，使用这些 gem ，一下子就会把功能做完了。 修改 Gemfile，加入 will_paginate, gem ‘will_paginate’ Gemfile gem &#39;will_paginate&#39; 然后执行 bundle install 然后重开 rails server Step 2: 修改 groups_controller修改 app/controllers/groups_controller.rb 中的 show 加入分页代码，变成 app/controllers/groups_controller.rb 1234def show @group = Group.find(params[:id]) @posts = @group.posts.recent.paginate(:page =&gt; params[:page], :per_page =&gt; 5) end Step 3: 修改 groups/show.html.erb修改 app/views/groups/show.html.erb 在最下面 &lt;/table&gt; 下加入以下三行代码： app/views/groups/show.html.erb 123456 &lt;/tbody&gt;&lt;/table&gt;+ &lt;div class=&quot;text-center&quot;&gt;+ &lt;%= will_paginate @posts %&gt;+ &lt;/div&gt; 如果你的群组内，超过 5 篇文章（现在就去新增！！），就可以看到分页功能出现了。 Step 4: git 储存git add .git commit -m &quot;implement posts pagination with will_paginate&quot; **本节常见问题要去哪里才能知道，我想要的功能要用什么 gem 呢？*各种功能的gem一览： “RubyToolbox” 7-1 本章目标本章目标： 一个使用者可以选择“加入”、“退出”讨论群 群的创始者，创群一开始就应该加在群组里 7-2 建立“群成员”数据表目标 建立群成员的关系表 步骤Step 0. git checkout -b ch06因为我们现在要实作第六章的内容，新增一个 branch 把实作内容集中在 ch06 是比较合理的。将来回顾就可以比较清楚 在 ch06 我们做了哪一些练习。 git checkout -b ch06 Step 1: 建立 GroupRelationship我们在这里要建立一个新的 model 叫 GroupRelationship。这个数据表里面只有两个栏位： group_id ( integer ) user_id ( integer) 记录了“谁”参加了“哪个群组”。 输入 rails g model group_relationship group_id:integer user_id:integer 执行 rake db:migrate Step 2: 设定 Group 与 User 之间的关系 ( 使用者参与的所有群）在这之前，在 User model 已经有一行：has_many :groups app/models/user.rb 123456789class User &lt; ApplicationRecord# .. 略 has_many :groups# .. 略end user.groups 会捞出这个使用者“创造过的所有群”。那我们要如何撰写 “参与的所有群”呢？ 首先，修改 app/models/user.rb 加入以下两行 app/models/user.rb 12345678class User &lt; ApplicationRecord# .. 略+ has_many :group_relationships+ has_many :participated_groups, :through =&gt; :group_relationships, :source =&gt; :groupend 然后修改 app/models/group_relationship.rb，加入这两行 app/models/group_relationship.rb 1234class GroupRelationship &lt; ApplicationRecord+ belongs_to :group+ belongs_to :userend “参与的所有群”。 Step 3: 设定 Group 与 User 之间的关系 ( 群组内的所有会员 ）修改 app/models/group.rb，加入这两行 app/models/group.rb 12345678class Group &lt; ApplicationRecord # ... 略 + has_many :group_relationships+ has_many :members, through: :group_relationships, source: :userend Step 4: 动手测看看打开 rails console 输入 12345u = User.firstg = Group.firstg.members &lt;&lt; ug.membersu.participated_groups 看看会出现什么结果。最后执行exit退出 Step 5: git 储存git add .git commit -m &quot;implement group relation&quot; 7-3 在群组里面判断“是否群组成员”实作目标 会员要可以在社团里面看到自己“是否群组成员” 步骤Step 1. 在 user model 内实作判断式“是否为群组的一分子”让我们修改 app/models/user.rb ，在最后一个end的上面加入这一段 is_member_of?(group) app/models/user.rb 12345678class User &lt; ApplicationRecord # 略 ... + def is_member_of?(group)+ participated_groups.include?(group)+ end end 然后“重开”rails console 输入 123u = User.firstg = Group.firstu.is_member_of?(g) 结果会是这样： 运行 exit 退出console 我们等一下将会使用 is_member_of?(group)来判断“这个使用者是否属于该群组” Step 2. 修改 groups/show.html.erb我们在 app/views/groups/show.html.erb 加入这一段 app/views/groups/show.html.erb 1234567&lt;span class=&quot;pull-right&quot;&gt; &lt;% if current_user &amp;&amp; current_user.is_member_of?(@group) %&gt; &lt;label class=&quot;label label-success&quot;&gt; 群组成员 &lt;/label&gt; &lt;% else %&gt; &lt;label class=&quot;label label-warning&quot;&gt; 不是群组成员 &lt;/label&gt; &lt;% end %&gt;&lt;/span&gt; 你应该只会看到这两种结果 Step 3. git 存档git add .git commit -m &quot;implement is_member_of?(group)&quot; **本节常见问题is_member_of?(group) 为什么这一段要放在 User 的 model 里？ 因为它是要被 user 所使用的判断式 “?”问号在这里有任何意义吗？你可以暂时把它视为 “method 名字的一部分”，“暂时”没有意义。 7-4 “加入群组”或“退出群组”目标 实作 model 层 “加入群组” 实作 model 层“退出群组” 步骤步骤 1:app/models/user.rb 1234567def join!(group) participated_groups &lt;&lt; group end def quit!(group) participated_groups.delete(group) end 打开 rails console 输入 u = User.first g = Group.first u.join!(g) u.is_member_of?(g) u.quit!(g) u.is_member_of?(g) exit 步骤 2:git add .git commit -m &quot;join or quit group&quot; 7-5 实际操作“加入群组”或“退出群组”步骤Step 1:app/controllers/groups_controller.rb 123456789101112131415161718192021222324252627+ def join+ @group = Group.find(params[:id])+ + if !current_user.is_member_of?(@group)+ current_user.join!(@group)+ flash[:notice] = &quot;加入本讨论版成功！&quot;+ else+ flash[:warning] = &quot;你已经是本讨论版成员了！&quot;+ end+ + redirect_to group_path(@group)+ end+ + def quit+ @group = Group.find(params[:id])+ + if current_user.is_member_of?(@group)+ current_user.quit!(@group)+ flash[:alert] = &quot;已退出本讨论版！&quot;+ else+ flash[:warning] = &quot;你不是本讨论版成员，怎么退出 XD&quot;+ end+ + redirect_to group_path(@group)+ end private 加入与退出群组必须要是登入状态下才行，修改位於第二行的 before_action ，加入 join 和 quit 也需要验证 app/controllers/groups_controller.rb 123456class GroupsController &lt; ApplicationController- before_action :authenticate_user! , only: [:new, :create, :edit, :update, :destroy]+ before_action :authenticate_user! , only: [:new, :create, :edit, :update, :destroy, :join, :quit]...... Step 2: config/routes.rb 12345678resources :groups do+ member do+ post :join+ post :quit+ end resources :posts end Step 3:加入两行代码，将这个文件修改成这样： app/views/groups/show.html.erb 123456789&lt;span class=&quot;pull-right&quot;&gt; &lt;% if current_user &amp;&amp; current_user.is_member_of?(@group) %&gt; &lt;label class=&quot;label label-success&quot;&gt; 群组成员 &lt;/label&gt;+ &lt;%= link_to(&quot;Quit Group&quot;, quit_group_path(@group), method: :post, class: &quot;btn btn-default&quot;) %&gt; &lt;% else %&gt; &lt;label class=&quot;label label-warning&quot;&gt; 不是群组成员 &lt;/label&gt;+ &lt;%= link_to(&quot;Join Group&quot;, join_group_path(@group), method: :post, class: &quot;btn btn-default&quot;) %&gt; &lt;% end %&gt;&lt;/span&gt; Step 4:git add .git commit -m &quot;join &amp; quit group action&quot; 7-6 User 在建立 group 后自动成为 group 的一员目标当你创办了 group ，却还要手动再加入这个 group 不会很怪吗？ XD所以在这个步骤我们让 User 在建立 group 后自动成为 group 的一员 步骤Step 1 :app/controllers/groups_controller.rb 1234567891011def create @group = Group.new(group_params) @group.user = current_user if @group.save+ current_user.join!(@group) redirect_to groups_path else render :new end end Step 2:git add .git commit -m &quot;when created a group, join it automatically&quot; 8-1 本章目标目标 新增一个下拉选单 可以看到自己过去曾经发表的文章 可以看到自己过去曾经参与的社团 8-2 可以看到自己参与的所有群组目标 使用者在下拉选单内，可以看到 “My Groups” 使用者点选 “My Groups” 可以看到自己参与的所有群组 步骤Step 0. git checkout -b ch07因为我们现在要实作第七章的内容，新增一个 branch 把实作内容集中在 ch07 是比较合理的。将来回顾就可以比较清楚 在 ch07 我们做了哪一些练习。 git checkout -b ch07 Step 1: 产生 account 的 namespace 下的 groups_controller执行 rails g controller account/groups Step 2. 修改 routing修改 config/routes.rb 加入： config/routes.rb 123namespace :account do resources :groups end Step 3: 修改下拉选项然后修改 app/views/common/_navbar.html.erb 在“下拉选单选项”中多加入一个My Groups： app/views/common/_navbar.html.erb 12345&lt;ul class=&quot;dropdown-menu&quot;&gt;+ &lt;li&gt; &lt;%= link_to(&quot;My Groups&quot;, account_groups_path) %&gt;&lt;/li&gt;+ &lt;li class=&quot;divider&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;%= link_to(&quot;退出&quot;, destroy_user_session_path, method: :delete) %&gt; &lt;/li&gt; &lt;/ul&gt; 成果就会长这样： Step 4. 建立 account/groups_controller.rb 下的 index action记得要加入： before_action :authenticate_user!，限制必须要得登录使用者，才能看。 app/controllers/account/groups_controller.rb 1234567class Account::GroupsController &lt; ApplicationController before_action :authenticate_user! def index @groups = current_user.participated_groups endend Step 5. 新增 “参与群组一览表”touch app/views/account/groups/index.html.erb app/views/account/groups/index.html.erb 12345678910111213141516171819202122232425262728&lt;div class=&quot;col-md-12&quot;&gt; &lt;h2 class=&quot;text-center&quot;&gt; 我加入的讨论版 &lt;/h2&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; # &lt;/th&gt; &lt;th&gt; Title &lt;/th&gt; &lt;th&gt; Description &lt;/th&gt; &lt;th&gt; Post Count &lt;/th&gt; &lt;th&gt; Last Update &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% @groups.each do |group| %&gt; &lt;tr&gt; &lt;td&gt; # &lt;/td&gt; &lt;td&gt; &lt;%= link_to(group.title, group_path(group)) %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= group.description %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= group.posts.count %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= group.updated_at %&gt; &lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 成果： Step 6: git 储存git add .git commit -m &quot;implement my groups&quot; 8-3 可以看到自己发表的所有文章目标 使用者在下拉选单内，可以看到 “My Posts” 使用者点选 “My Posts” 可以看到自己发表的所有文章 步骤Step 1: 产生 account 的 namespace 下的 posts_controller执行 rails g controller account/posts Step 2. 建立 account/posts_controller.rb 下的 index action加入： before_action :authenticate_user!，限制必须要得登入使用者，才能看。 app/controllers/account/posts_controller.rb 123456class Account::PostsController &lt; ApplicationController before_action :authenticate_user! def index @posts = current_user.posts endend Step 3. 修改 routing 修改 config/routes.rb 加入 resources :posts config/routes.rb 1234namespace :account do resources :groups+ resources :posts end Step 4: 修改下拉选项然后修改 app/views/common/_navbar.html.erb 加入多一个“下拉选单选项”： app/views/common/_navbar.html.erb 123456&lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt; &lt;%= link_to(&quot;My Groups&quot;, account_groups_path) %&gt;&lt;/li&gt;+ &lt;li&gt; &lt;%= link_to(&quot;My Posts&quot;, account_posts_path) %&gt;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;%= link_to(&quot;退出&quot;, destroy_user_session_path, method: :delete) %&gt; &lt;/li&gt; &lt;/ul&gt; 成果就会长这样： Step 5. 新增 “发表文章一览表”touch app/views/account/posts/index.html.erb app/views/account/posts/index.html.erb 123456789101112131415161718192021222324252627&lt;div class=&quot;col-md-12&quot;&gt; &lt;h2 class=&quot;text-center&quot;&gt; 我发表过的文章 &lt;/h2&gt; &lt;table class=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; Content &lt;/th&gt; &lt;th&gt; Group Name &lt;/th&gt; &lt;th&gt; Last Update &lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;% @posts.each do |post| %&gt; &lt;tr&gt; &lt;td&gt; &lt;%= post.content %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= post.group.title %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= post.updated_at %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= link_to(&apos;Edit&apos;, edit_group_post_path(post.group, post), class: &quot;btn btn-default btn-xs&quot;) %&gt;&lt;/td&gt; &lt;td&gt; &lt;%= link_to(&apos;Delete&apos;, group_post_path(post.group, post), method: :delete, data: &#123; confirm: &quot;Are you sure?&quot; &#125;, class: &quot;btn btn-default btn-xs&quot;) %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% end %&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 成果： Step 6: git 储存git add .git commit -m &quot;implement my posts&quot; 额外作业：（这次没有解答） 练习自己实作“编辑”和“删除”按钮这两个功能！ **本节常见问题步骤5做了以后，浏览器出现红色报错可能是之前的操作，有遗留一些数据，在目前的环境里产生报错。删除它们就好了。 在终端打开 rails console 输入 post = Post.allpost.delete_allexit 9-1 本章目标目标 了解 Helper 是什么，怎么使用 了解 Partial 是什么，怎么使用 9-2 系统内建 Helper “simple_format”的使用目标 让群组叙述能够正确的断行 当你开始使用这个系统时，你会发现一件很奇怪的事，输入三行叙述 却没有断行 我们这一节要讲的就是如何正确的断行 步骤：Step 0. git checkout -b ch08因为我们现在要实作第八章的内容，新增一个 branch 把实作内容集中在 ch08 是比较合理的。将来回顾就可以比较清楚 在 ch08 我们做了哪一些练习。 git checkout -b ch08 Step 1. 将 group.description 改成 simple_format(group.description)修改 app/views/groups/index.html.erb app/views/groups/index.html.erb 1234 &lt;td&gt;&lt;%= link_to(group.title, group_path(group)) %&gt;&lt;/td&gt;- &lt;td&gt;&lt;%= group.description %&gt;&lt;/td&gt;+ &lt;td&gt;&lt;%= simple_format(group.description) %&gt;&lt;/td&gt; &lt;td&gt; &lt;%= group.user.email %&gt; &lt;/td&gt; 然后你就可以看到正确的断行 git add .git commit -m &quot;use simple_format helper to decorate&quot; **本节常见问题为什么会有这样的差别？让我们捞出 Log，你可以观察到，其实系统存的是这样的格式，断行是 \r\n。很遗憾的 HTML 并不认得 \r\n 是什么。HTML 只知道断行符号应该叫&lt;br&gt; simple_format 是 Rails 内建的 Helper，可以帮忙把 \r\n 翻译成为 &lt;br&gt; 什么是 Helper？Helper 的意思是“小方法”，View 用的小方法，Rails 内建很多这种有趣的小东西。这里有更多小方法：http://api.rubyonrails.org/classes/ActionView/Helpers/TextHelper.html 9-3 使用自定义 Helper目标 用到 group.description 的地方很多，老是直接写 simple_format(group.description) 不是很好，万一以后产品经理想要加个什么特效，我们可能会改死 我们也想要发明“自己的 Helper” 步骤Step 1. 自制 render_group_description(group)修改 app/helpers/groups_helper.rb 加入： app/helpers/groups_helper.rb 12345module GroupsHelper def render_group_description(group) simple_format(group.description) endend 然后修改 app/views/groups/index.html.erb 与 app/views/account/groups/index.html.erb 里关于 group.description 的部分（最终代码如下）： app/views/groups/index.html.erb 123&lt;td&gt;&lt;%= link_to(group.title, group_path(group)) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= render_group_description(group) %&gt;&lt;/td&gt; &lt;td&gt; &lt;%= group.user.email %&gt; &lt;/td&gt; app/views/account/groups/index.html.erb 1234&lt;td&gt;&lt;%= link_to(group.title, group_path(group)) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= render_group_description(group) %&gt;&lt;/td&gt; &lt;td&gt; &lt;%= group.posts.count %&gt; &lt;/td&gt; &lt;td&gt; &lt;%= group.updated_at %&gt; &lt;/td&gt; Step 2 : git 储存git add .git commit -m &quot;use self delimit helper&quot; **本节常见问题自制的 Helper 是什么意思？ Helper 就是用 Ruby 写的“View 装饰的小方法”，你也可以自己定义 自制 Helper 都会放在 app/helpers 下 10-1 上传到 Github 指南目标 把练习作业上传到 Github 步骤：Step 1. 到 Github 开设 repo 如果你是做第一遍，就开 rails101 如果你是做第二遍，就开 rails101-1 如果你是做第三遍，就开 rails101-2 像我这样 Step 2. 上传 Git 进度到 Github我们每次在github上新建立一个repo后，都要执行以下两条指令： 分别在终端输入以上两条指令：git remote add origin git@github.com:你的github名字/rails101-1.gitgit push -u origin master Step 3. 上传“所有进度”因为我们这一次有做了很多“branch”，但是复制执行step2的两行命令只会让我们 push上去master一个分支而已。当我们新建立其他分支以后，在终端输入以下指令： git push --all origin 这样就会把你所有的进度都推上去。 成果： 一切都顺利的话，你可以在 Github 上看到所有的 branch 10-2 上传到 Heroku 指南Step 1：确认本地运行一切正常有bug请先解决掉，否则上传會失败。 Step 2：修改sqlite3加入pg这个gem修改 Gemfile 文件把 sqlite3 从第7行搬到约第30到40行的group :development, :test do 这一行里面，置于gem ‘byebug’的下面。 在末尾新增一个 production group，加上 pg 这个 gem 123group :production do gem &apos;pg&apos;end command+s 存档 修改 Gemfile 后要 bundle install 存档 git add . git commit -m &quot;move sqlite3 to dev group &amp; add pg to production group &quot; 具体可以参考第一课相关章节以及帮助文档 Step3：在 Heroku 建立新项目首先记得登入heroku login 创建heroku create 小提示：因为heroku为远端连结，需要等待一段时间，如果无法连上，可以尝试换一个VPN再操作。 Step 4：上传到 heroku在终端输入git push heroku ch08:master 因为我们的最新进度在 ch08。 Step 5：跑 heroku run rake db:migrate执行 heroku run rake db:migrate Step 6：大功告成！交作业吧恭喜你完成！把你的 heroku 网址贴上作业栏位吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy this is a new line,lalalalaMore info: Deployment]]></content>
    </entry>

    
  
  
</search>
